---
title: "CSE 130 - Principles of Computer Systems Design Notes"
excerpt_separator: "<!--more-->"
classes: "wide"
categories:
  - Notes

tags:
  - 
  - 
---

## Systems

A **system** is a set of interconnected components that has an expected behavior observed at the interface with its environment.

Systems can be divided into four categories: emergent properties, propogation of effects, incommensurate scaling, and trade-offs.
- Emergent properties $\to$ properties that are not evident in the individual components of a system,but show up when combining those components.

- Propogation of effects $\to$ a small ruption or local change can have effects that reach from one end of the system to another.

- Incommensurate scaling $\to$ as a system scales in size and speed, not all of its parts will follow the same scaling rules, and things will break as a result.

- Trade-offs $\to$ trade-offs begin with the observation that there is some limited form of goodness, and the design challenge is to first *maximize* the goodness, second to *avoid* wasting it, and third to *allocate* it to the place that needs it the most.

Large systems are **complex**, which we can define as:
  - Large number of components
  - Large number of interconnections between components
  - Many irregularities (exceptions complicate understanding)
  - A long description formulized as “Kolmogorov complexity”: a computational object as the length of its shortest specification
  - A team of designers, implementers, or maintainers  

### Principles of Complexity
**Principle of escalating complexity:** adding a requirement increases complexity out of proportion.
**Avoid excessive generality:** generality increases complexity.  
**Systems *change*:** as time passes, we may realize that some features aren't as important as we first thought, or we need new features, or our environment changes (ie faster hardware).  
**Law of diminishing returns:** the more one improves some measure of goodness, the more effort the next improvement will require.

### Dealing with Complexity
**Modularity:** we can analyze and design systems as a collection of interacting subsystems. This allows us to consider interactions between components within a module without having to worry about components from other modules.
  - **The unyielding foundations rule:** It is easier to change a module than to change the modularity.  

**Abstraction:** There must be little or no propogation of effects from one module to another. We should treat other modules as black-boxes, and assume that other modules are working as intended. 
  - In order for this to work we employ **the robustness principle:** Be tolerant of inputs and strict on outputs. **NOTE:** It may be better to just kill a program if the input isn't what we expected, to avoid propagating effects of bad or faulty inputs that leak to other modules.
  - **The safety margin principle:** Keep track of the distance to the cliff, or you may fall over the edge. We need to track and report all out-of-tolerance inputs.

**Layering:** One builds on a set of mechanisms that is already complete (a lower layer) and uses them to create a different complete set of mechanisms (an upper layer).  
  - A layer may be made up of multiple modules, but a module from a given layer may only interact with other modules in the same layer or modules of next higher or next lower layer.

**Hierarchy:** Start with a small group of modules, and assemble them into a stable, self-contained subsystem that has a well-defined interface. Next, assemble a small group of subsystems to produce a larger subsystem. This process continues until the final system has been constructed from a small number of relatively large subsystems.

We can use *binding*, which is the process of combining modules to implement a desired feature.
  - **decouple modules with indirection:** Indirection supports replaceability. We can use a name to delay or allow changing of a bind.

### Computer Systems have no nearby Bounds on Composition
1) The complexity of a computer system is not limited by physical laws. Computer systems are complex because not only do we have to worry about how computers work at the hardware level (chip design, logic gates, etc), which are bounded by physical laws, but we also need to worry about software limits (which are only really hard-bound by hardware requirements), which are generally bound by how fast people can create it.
  - As software grows, we deal with *leaky abstractions*, where modules don't completely conceal the underlying implementation details.

2)$\frac{d(technology)}{dt}$ is unprecedented.
  - We run into the **the incommensurate scaling rule:** Changing any system parameter by a factor of 10 usually requires a new design.


**Iteration** is a key concept, for building complex systems. Let's start with a simple, working system that meets some requirements, and iteratively improve from there.
  - **Design for iteration:** You won’t get it right the first time, so make it easy to change.
    - *Take small steps.* Allow for the discovery of bad ideas and design mistakes quickly.
    - *Don’t rush.* Make sure each step is well planned.
    - *Plan for feedback.* Include feedback paths in the designs as well as incentives to provide feedback.
    - *Study failures.* Complex systems fail for complex reasons.
  
## Memory
**Memory** is a system component that remembers data values for use in computation. Memory can be abstracted into models that have two operations: ```write(name,value)``` and ```value = read(name)```.

  - *volatile memory* is memory that requires power to retain information. Ex: ram, cache, registers, etc  
  - *non-volatile memory* is durable, and doesn't require power to maintain its contents.

**Read/write coherence:** result of the ```READ``` of anamed cell is always the same as the most recent ```WRITE``` to that cell.  
**Before-or-after atomicity:** result of every ```READ``` or ```WRITE``` occured either completely before or completely after any other ```READ``` or ```WRITE```.  

Threats to read/write coherence and before-or-after atomicity include:
  - *Concurrency:* systems where different actors can perform ```READ``` and ```WRITE``` operation concurrently on the same named cell.  
  - *Remote storage:* when memory device is physically distant, we ask the question of which ```WRITE``` operation was the most recent.  
  - *Performance enhancements:* optimized compilers and high-performance processors do alot of complex operations at the software and hardware level that can added levels of complexity.  
  - *Cell size incommensurate with value size:* large values may occupy multiple memory cells, which require special ahndling for this case.  
  - *Replicated storage:* reliability of storage can be icnreased by making multiple copies of values and placing them in distinct storage cells.

**Memory latency** is the time it takes for a ```READ``` or ```WRITE``` operation to complete (also called access time).  

**Interpreters** are active elements of a computer system: they perform the *actions* that constitute computations.  
  - *instruction reference:* tells interpreter where to find the next instruction  
  - *repertoire:* set of actions the interpreter will perform when it retrieves an instruction from the instruction reference  
  - *environment reference:* tells the interpreter where to find its *environment*, the current state of which the interpreter should perform the action of the current instruction.

When building systems out of subsystems, it is essential to be able to use a subsystem without having to know details of how that subsystem refers to its components. Names are thus used to achieve modularity, and at the same time, modularity must sometimes hide names.

*Indirection:* decoupling one object from another by using a name as an intermediary.  

A system designer creates a *naming scheme*, which consists of three elements:
  - A *name space*, which comprises an alphabet of symbols together with syntax rules that specifry which names are acceptable.  
  - A *name-mapping algorithm*, which associates some names of the name space with some values in a *universe of values*.  
  
